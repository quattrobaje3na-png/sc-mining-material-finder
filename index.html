<script>
    let oreData, sysGroups, refMapping;
    const statusText = document.getElementById('status');
    const BASE_URL = 'https://raw.githubusercontent.com/quattrobaje3na-png/sc-mining-tool/main/';

    const loadJson = (file) => fetch(BASE_URL + file, {cache: "no-store"})
        .then(r => { if(!r.ok) throw new Error(file); return r.json(); });

    Promise.all([
        loadJson('ore_locations.json'),
        loadJson('system_sorting.json'),
        loadJson('reference.json')
    ]).then(res => {
        [oreData, sysGroups, refMapping] = res;
        statusText.innerText = "READY: MULTI-STREAM SYNC COMPLETE";
        statusText.style.color = "#00FF00";
    }).catch(err => {
        statusText.innerText = "SYNC_ERROR: UNABLE TO LOAD " + err.message.toUpperCase();
        statusText.style.color = "red";
    });

    function scan() {
        const out = document.getElementById('results');
        const system = document.getElementById('sys-select').value;
        // Collects all 3 picks and filters out empty ones
        const picks = Array.from(document.querySelectorAll('.ore-sel'))
                           .map(s => s.value)
                           .filter(v => v);

        out.innerHTML = "";
        if (!oreData || !sysGroups || !refMapping) return;

        const activeGroup = sysGroups.star_system_groups[system] || [];
        const validLocations = refMapping.location_mapping || {};
        const matches = [];

        for (let loc in oreData) {
            // Check if location is in the selected system group
            if (!activeGroup.includes(loc)) continue;
            // Check if location has a display name in reference.json
            if (!validLocations[loc]) continue;

            let foundOres = [];
            let maxProb = 0;

            picks.forEach(p => {
                const locOres = oreData[loc].ores || {};
                // Case-insensitive matching for materials
                const matchKey = Object.keys(locOres).find(k => k.toLowerCase() === p.toLowerCase());
                
                if (matchKey) {
                    let prob = locOres[matchKey].prob || 0;
                    foundOres.push({ 
                        name: matchKey.toUpperCase(), 
                        val: (prob * 100).toFixed(1) 
                    });
                    if (prob > maxProb) maxProb = prob;
                }
            });

            if (foundOres.length > 0) {
                matches.push({ 
                    name: validLocations[loc], 
                    ores: foundOres, 
                    sortVal: maxProb 
                });
            }
        }

        if (matches.length === 0) {
            out.innerHTML = "<p style='color:#665500;'>NO VERIFIED DATA FOUND IN THIS REGION</p>";
        } else {
            // Sort by highest probability material found
            matches.sort((a, b) => b.sortVal - a.sortVal).forEach(m => {
                const card = document.createElement('div');
                card.className = "card";
                let rows = m.ores.map(o => `<div class="row"><span>${o.name}</span><span>${o.val}%</span></div>`).join('');
                card.innerHTML = `<strong>${m.name}</strong>${rows}`;
                out.appendChild(card);
            });
        }
    }
</script>
